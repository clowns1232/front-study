# SSR과 CSR의 차이점

# SSR

**S**erver **S**ide **R**endering의 약자로 서버에서 렌더링 준비를 끝마친 상태로 클라이언트로 전달하는 방식입니다.

![Untitled](./SSR과%20CSR의%20차이점/Untitled.png)

1. 유저가 서버에 요청을 보냅
2. 서버에서 즉시 렌더링이 가능한 HTML파일을 만듭니다.
3. 클라이언트는 해당 HTML을 받고 즉시 렌더링이 됩니다.
    1. 단 JS가 아직 읽히기 전이므로 사이트 조작이 불가능하다
4. 클라이언트가 JS를 다운받고 실행합니다.
    1. 다운받기 이전의 유저 조작을 기억하고 실행합니다.
5. 즉. 서버에서 이미 '렌더 가능한' 상태로 클라이언트에 전달되기 때문에, JS가 다운로드 되는 동안 사용자는 **무언가**를 보고 있을 수 있다.

# CSR

Client Side Rendering의 약자로 말 그대로 렌더링이 클라이언트에서 일어나는 방식입니다.

![Untitled](./SSR%EA%B3%BC%20CSR%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90/Untitled%201.png)

1. 유저가 웹사이트에 요청을 보냄
2. HTML과 JS를 다운받는다.
    1. 이때 SSR과 달리 유저는 화면을 볼 수 없다.
3. JS를 실행하고 데이터를 위해 API가 호출된다.
    1. 이때 유저는 placeholder를 보게 됩니다.
4. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.
5. 즉, 서버에서 처리 없이 클라이언트로 보내주기 때문에 자바스립트가 모두 다운로드 되고 실행이 끝나기 전까지 사용자는 볼수 있는게 없다.

# 1. SSR과 CSR의 차이점

## 1.1 웹페이지를 로딩하는 시간

- 첫 페이지 로딩시간

CSR의 경우 리소스를 한번에 불러오고 SSR은 유저가 보는 해당 페이지의 리소스만을 불러오기 떄문에 SSR이 좀 더 빠릅니다.

- 나머지 로딩시간

첫 페이지 로딩 이후 다른 페이지로 이동할 떄 CSR은 이미 모든 스크립트를 로딩을 했기 떄문에 빠르게 이동이 가능하지만 SSR은 해당 페이지의 리소스를 다시 서버에 요청해서 받아와야 하기 때문에 느립니다.

## 1.2 SEO 대응

검색 엔진은 자동화된 `크롤러`가 웹사이트가 읽게 되는데 지금까지의 크롤러는 자바스크립트를 읽지않기 때문에 SEO에 대응하기 힘듭니다.

> 단 구글의 경우 자바스크립트까지 읽습니다. 단 완벽하지는 않습니다.
> 

> 또한 CSR도 크롤러가 잘 읽을 수 있도록 하는 방법이 있습니다. 단 SSR보다 방법이 어렵습니다.
> 

하지만 SSR은 이미 서버에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러가 좀 더 잘 읽습니다.

## 1.3 사용 권장 예시

- 네트워크가 느릴 때 (CSR은 한번에 모든 것을 불러오지만 SSR은 각 페이지마다 나눠불러오기 때문)
- SEO(serach engine optimization : 검색 엔진 최적화)가 필요할 때.
- 최초 로딩이 빨라야하는 사이트를 개발 할 때
- 메인 스크립트가 크고 로딩이 매우 느릴 때CSR은 메인스크립트가 로딩이 끝나면 API로 데이터 요청을 보낸다. 하지만 SSR은 한번의 요청에 아예 렌더가 가능한 페이지가 돌아온다.
- 웹 사이트가 상호작용이 별로 없을 때.

CSR을 사용하자

- 네트워크가 빠를 때
- 서버의 성능이 좋지 않을 때
- 사용자에게 보여줘야 하는 데이터의 양이 많을 때.(로딩창을 띄울 수 있는 장점이 있다.)
- 메인 스크립트가 가벼울 때
- SEO 따윈 관심 없을 때
- 웹 어플리케이션에 사용자와 상호작용할 것들이 많을 때. (아예 렌더링 되지 않아서 사용자의 행동을 막는 것이 경험에 오히려 유리함.)